# rubberRing

## Кратко

Данная библиотека предоставляет готовую реализацию растущего циклического буфера

Имеется 2 варианта буфера:
- потоконебезопасный RubberRing
- потокобезопасный SyncRubberRing

### Ключевые особености

- нет эвакуаций
- лишняя память высвобождается (происходит сжатие буфера)
- гибкая настройка выделяемого пространства и управления памятью

## Быстрый старт

### Простой буфер

```go
rr := rubberring.NewRubberRing[int]( //создаем буфер
	rubberring.WithStartChankCount(2), // количество первоночально инициируемых чанков
	rubberring.WithStartChankSize(2), // размер изначально инициируемых чанков
	rubberring.WithGrowStrategy(func(_ int) (int, int) { return 2, 2 }), // функция роста (на вход текущее капасити, возвращает размер новых чанков и их количество)
	rubberring.WithFreeChankBufferSize(2), // размер буфера для пасивных чанков
)

rr.Push(1) // пишем в буфер
val, err := rr.Pull() // читаем из буфера
```

### Синхронный буфер буфер

```go
rr := rubberring.NewSyncRubberRing[int]( //создаем буфер
	rubberring.WithStartChankCount(2), // количество первоночально инициируемых чанков
	rubberring.WithStartChankSize(2), // размер изначально инициируемых чанков
	rubberring.WithGrowStrategy(func(_ int) (int, int) { return 2, 2 }), // функция роста (на вход текущее капасити, возвращает размер новых чанков и их количество)
	rubberring.WithFreeChankBufferSize(2), // размер буфера для пасивных чанков
)

rr.Push(1) // пишем в буфер
val, err := rr.Pull(ctx) // читаем из буфера
```

## Как это работает

По факту буфер содержит в себе масив поделенный на чанки и буфер настраиваемого размера для пасивных чанков.

Каждый раз когда чанк с начала буфера высвобождается, он переносится в буфер дял пасивных чанков. Если буфер уже полон - чанк утилизируется (сборшиком мусора). Таким образом происходит сжатие буфера.

Каждый раз когда последний чанк заполняется, буфер пытается загрузить чанк из буфера пасивных чанков, если тот пуст - создаются новые чанки.

![Схема](docs/scheme.drawio.svg)

## Описание

### Опции конструктора

- `WithStartChankCount(int)` - количество чанков создаваемых при инициализации буфера (по умолчанию 4)
- `WithStartChankSize(int)` - размер создаваемых чанков при инициализации буфера (по умолчанию 256)
- `WithPassiveChankBufferSize(int)` - размер буфера пасивных чанков (по умолчанию 3)
- `WithGrowStrategy(func(currentCapacity int) (newChankSize, newChankCount int))` - функция описывающая размер и количество создаваемых чанков при заполнении буфера

Манипулируя этими параметрами, можно настроить поведение буфера под разные задачи.

### Методы RubberRing

- `Push(V)` - помещает элемент в конец буфера
- `Pull() (V, error)` - извлекает элемент из начала буфера. Если буфер пуст вернется ошибка `io.EOF`
- `Size() int` - вернет текушее количество данных в буфере
- `Capacity() int` - вернет текуший размер буфера (включая пасивную вместимость)
- `Stat() RubberRingStat` - вернет подробное описание состояния буфера
- `Elements() iter.Seq[V]` - вернет итератор для получения всех элементов буфера

### Методы SyncRubberRing

SyncRubberRing имеет те же методы что и RubberRing они работают аналогично (с поправкой на потокобезопасность) за следующими исключениями
- `Pull(context.Context) (V, error)` - извлекает элемент из начала буфера. Если буфер пуст - дожидается пока там появится хотя бы один элемент. Если закрыть контекст - вернет ошибку context.Canceled
- `Elements() iter.Seq[V]` - вернет итератор для потокового получения элементов из буфера. При закрытии контекста - итератор завершится.
